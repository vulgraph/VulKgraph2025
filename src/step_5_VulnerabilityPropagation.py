from py2neo import Graph, Node, Relationship,Subgraph,NodeMatcher
import re
import os
import json
import time
from urllib.parse import quote
import threading
import subprocess
from Node import CVE,Software,LibVersion


# 连接到Neo4j
graph=Graph("http://localhost:7474", auth=("neo4j", "neo4j"),name="neo4j")

def extract_dependency_tree(graph, root_software):
    dependency_tree = []

    # 使用DFS深度优先搜索依赖树
    def dfs(current_software):
        nonlocal dependency_tree
        dependency_tree.append(current_software)

        # 使用match方法查询当前软件的所有依赖关系
        query = """
        MATCH (s1:Software)-[r:REUSES]->(s2:Software)
        WHERE s1.unique_id = $unique_id
        RETURN s2
        """
        result = graph.run(query, unique_id=current_software.unique_id)
        
        for record in result:
            next_software_node = record["s2"]
            next_software = Software(next_software_node["name"], next_software_node["author"], next_software_node["path"], next_software_node["entity_type"])
            dfs(next_software)

    dfs(root_software)
    return dependency_tree

def process_dependency_tree(graph, start_software_name):
    # 构建从指定软件开始的依赖树
    dependency_tree = build_dependency_tree(graph, start_software_name)
    return dependency_tree

def extract_dependency_tree_and_count_levels(graph, root_software):
    dependency_tree = []
    level_counts = {1: 0, 2: 0, 3: 0}  # 初始化各级依赖数量

    # 使用DFS深度优先搜索依赖树
    def dfs(current_software, level):
        nonlocal dependency_tree, level_counts
        dependency_tree.append(current_software)

        # 如果当前级别是1到3，则增加相应的计数
        if level in level_counts:
            level_counts[level] += 1

        # 使用match方法查询依赖当前软件的所有软件
        query = """
        MATCH (s2:Software)-[r:REUSES]->(s1:Software)
        WHERE s1.unique_id = $unique_id
        RETURN s2
        """
        result = graph.run(query, unique_id=current_software.unique_id)
        
        for record in result:
            next_software_node = record["s2"]
            next_software = Software(next_software_node["name"], next_software_node["author"], next_software_node["path"], next_software_node["entity_type"])
            dfs(next_software, level + 1)

    # 从根软件开始，层级为1
    dfs(root_software, 1)
    return dependency_tree, level_counts


def process_vulnerability_graph():
    print(1)


# 构造根软件节点
'''root_software = Software(name="linux", author="torvalds", path=None, entity_type="Library")

# 提取依赖树
dependency_tree = extract_dependency_tree(graph, root_software)

# 打印依赖树中的软件节点信息
# for software in dependency_tree:
#     print(software.name)

dependency_tree, level_counts = extract_dependency_tree_and_count_levels(graph, root_software)

print("依赖树:", dependency_tree)
print("各级依赖数量:", level_counts)'''

def find_top_dependency_software(graph):
    query = """
    MATCH (root:Software)
    OPTIONAL MATCH (root)<-[:REUSES]-(dep1:Software)
    WITH root, count(DISTINCT dep1) AS Level1Dependencies
    OPTIONAL MATCH (dep1)<-[:REUSES]-(dep2:Software)
    WITH root, Level1Dependencies, count(DISTINCT dep2) AS Level2Dependencies
    OPTIONAL MATCH (dep2)<-[:REUSES]-(dep3:Software)
    WITH root, Level1Dependencies, Level2Dependencies, count(DISTINCT dep3) AS Level3Dependencies
    RETURN root.name AS Software, root.author AS Author, Level1Dependencies, Level2Dependencies, Level3Dependencies, (Level2Dependencies + Level3Dependencies) AS TotalLevel23Dependencies
    ORDER BY TotalLevel23Dependencies DESC
    LIMIT 10
    """
    results = graph.run(query)
    print("Top Dependent Softwares (Level 2 + Level 3):")
    for record in results:
        print(f"Software: {record['Software']}, Author: {record['Author']}, Level 1: {record['Level1Dependencies']}, Level 2: {record['Level2Dependencies']}, Level 3: {record['Level3Dependencies']}, Total Level 2 + 3: {record['TotalLevel23Dependencies']}")


find_top_dependency_software(graph)